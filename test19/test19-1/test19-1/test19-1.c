#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//操作符讲解
//// / 和 %
//int main()
//{
//	//int a = 5 / 2;//商2余1
//	//printf("%d\n",a);//2
//	//a = 5 % 2; //取模操作符两边都必须是整数
//	//printf("%d\n", a);//1
//	//若要得到2.5
//	float a = 5 / 2;//错误
//	a = 5.0 / 2; //除号两边得有一个是浮点型不能全是整形
//	printf("%lf\n", a);
//	return 0;
//}

// 移位操作符   只能作用于整数
//int main()
//{
//	//int a = 16;
//	//// >> - 右移操作符    
//	////1. 算术右移   右边丢弃 左边补原符号位  负数补1  正数补0   目前编译器多采用算术移位
//	////2. 逻辑右移   右边直接丢弃  左边直接补0
//	////移动的是二级制位
//	////00000000000000000000000000010000
//	////00000000000000000000000000001000
//	//int b = a >> 1;
//	//printf("%d\n",b);
//	int a = -1;//负数按补码储存   负数补码 = 负数原码反码 + 1   正数原码反码补码相同
//	int b = a >> 1;
//	// a的原码10000000000000000000000000000001
//	// a的反码11111111111111111111111111111110   反码符号位不变  其他位相反
//	// a的补码11111111111111111111111111111111   补码等于反码+1
//	//右移之后11111111111111111111111111111111   补码没变  说明值也没有变
//	printf("%d\n", b);
//	return 0;
//}

//左移    直接丢弃左边  右边补0  不分算术移位和逻辑移位 直接补0即可
//int main()
//{
//	int a = 5;
//	int b = a << 1;
//	//00000000000000000000000000000101
//	//00000000000000000000000000001010
//	printf("%d\n",b);
//	return 0;
//}
////警告:对于移位操作符，不要移动负数位，这个是标准未定义的，列如：
//// int num = 10;
//// num >> -1; //error

//位操作符
//1. & 按位与	
//2. | 按位或
//3. ^ 按位异或   相同为0 相异为1
// 注：他们的操作数必须是整数
//int main()
//{
//	////& - 按2进制位与
//	//int a = 3; //011
//	//int b = 5; //101
//	//int c = a & b;  //001
//	//printf("%d\n",c);
//	//| - 按2进制位或
//	//int a = 3; //011
//	//int b = 5; //101
//	//int c = a | b; //111
//	//printf("%d\n", c);
//	//^ - 按2进制异或
//	int a = 3; //011
//	int b = 5; //101
//	int c = a ^ b; //110
//	printf("%d\n", c);
//	return 0;
//}

//一道面试题，不使用第三个变量实现两个数的交换
//1.方法1:加减法   a = a + b   b = a - b  b = (a + b) - b  a = (a + b) - a
//缺陷:a 和 b 都是整形，若a 和 b 的值均很大  相加时可能会溢出 导致结果错误
//int main()
//{
//	int a = 5;
//	int b = 3;
//  printf("before: a = %d , b = %d\n",a,b);
//	a = a + b;
//	b = a - b;
//	a = a - b;
//  printf("after: a = %d , b = %d\n",a,b);
//	return 0;
//}

//2.方法2:异或法  a = a ^ b   b = a ^ b   a = a ^ b
//缺点：执行效率不高  可读性不强
//int main()
//{
//	int a = 5;//110
//	int b = 3;//011
//  printf("before: a = %d , b = %d\n",a,b);
//	a = a ^ b;// 结束第一次异或之后 a 101
//	b = a ^ b;// 第二次异或 b = 101 ^ 011   b 110  已经完成  b = a的交换了
//	a = a ^ b;// 第三次异或 a = 101 ^ 110   a 011  已经完成  a = b的交换了
//  printf("after: a = %d , b = %d\n",a,b);
//	return 0;
//}

//练习:编写代码实现:求一个整数存储在内存中的二进制中1的个数   即该数补码中1的个数
//方法1   不断的 % 2  / 2  思路来源求10进制的数字的每一位数  123 % 10 = 3   123 / 10 = 12   12 % 10 = 2
//缺点   无法求负数的二进制中1的个数
//int main()
//{
//	int num = 0;
//	int count = 0;
//	printf("请输入一个想要求的整数:");
//	scanf("%d",&num);
//	while (num)
//	{
//		if (num % 2 == 1)  //判断最后一个二进制位是不是1
//		{
//			count++;
//		}
//		num = num / 2;//相当于右移一位
//	}
//	printf("该整数存储在内存中的二级制中的1的个数为:%d\n",count);
//	return 0;
//}

//方法2   让所求数与1按位与 能判断最后一位是1还是0  然后将所求数不断的右移 直到移完32位
//int main()
//{
//	//32个bit位
//	//00000000000000000000000000000110
//	//00000000000000000000000000000001   让所求数与1按位与 能判断最后一位是1还是0  然后将所求数不断的右移 直到移完32位
//	int num = 0;
//	int i = 0;
//	int count = 0;
//	printf("请输入一个想要求的整数:");
//	scanf("%d",&num);
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((num >> i) & 1))
//		{
//			count++;
//		}
//	}
//	printf("该整数存储在内存中的二级制中的1的个数为:%d\n", count);
//	return 0;
//}

//赋值操作符   一个 =  
//int main()
//{
//	int a = 10;
//	int x = 0;
//	int y = 20;
//	a = x = y + 1;// 连续赋值  从右往左计算   x = y + 1   a = x
//	return 0;
//}

//混合赋值操作符
//int main()
//{
//	int a = 10;
//	a = a + 2;
//	a += 2;
//
//	a = a >> 1;
//	a >>= 1;
//	
//	a = a & a;
//	a &= a;
//	return 0;
//}

//单目操作符   只有一个操作数   a + b  +旁边有两个操作数  所以 + 叫做双目操作符
//! - 逻辑反操作              - - 负值                  + - 正值                    & - 取地址  
//sizeof - 操作数的类型长度（以字节为单位）   ~ - 对一个二进制按位取反      -- - 前置、后置减减
//++ - 前置、后置加加                                         * - 间接访问操作符（解引用操作符）
int main()
{
	//! - 逻辑反操作 
	//int a = 0;
	////printf("%d\n",!a);  0的反为1   但是不是只有1的反为0   只要是一个正数的反都为0
	//if (!a)
	//{
	//	printf("呵呵\n");
	//}
	//& - 取地址			* - 间接访问操作符（解引用操作符）
	//int a = 10;
	//int* p = &a;//取地址操作符&
	//*p = 20;//解引用操作符*
	//printf("a = %d\n",a);
	//sizeof - 操作数的类型长度（以字节为单位）   sizeof 求类型时不能省略括号   sizeof(int)   sizeof int  //error
 	int a = 10;
	char c = 'r';//一个字节  4位
	int* p = &a;//地址要看存储地址的是多少位  有可能是32位  也有可能是64位  char*  和  int*  的字节数相同  因为都是一个地址
	int arr[10] = { 0 }; 
	printf("%d\n",sizeof(a));
	printf("%d\n", sizeof a);
	printf("%d\n", sizeof(int));

	printf("%d\n", sizeof(c));
	printf("%d\n", sizeof(char));

	printf("%d\n", sizeof(p));
	printf("%d\n", sizeof(char*));

	printf("%d\n", sizeof(arr));
	printf("%d\n", sizeof(int[5]));
	return 0;
}