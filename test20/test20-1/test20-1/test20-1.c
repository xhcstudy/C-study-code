#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//int main()
//{
	//short s = 0;
	//int a = 5;
	//printf("%d\n",sizeof(s = a + 5));//2   a+5  是整形 但是存在s内  就是短整型
	//printf("%d\n",s);//0  sizeof ()内部的表达式不参与运算的   s值不会发生变化

	// ~  -  按位(2进制位)取反操作符
	//int a = 0;
	//printf("%d\n",~a);// - 1

	//将一个数的某一个位由1改成0
	//应该将这个数与一个除这位位0其他位为1的数相与
	//得到这样一个数很困难，但不妨得到一个其他位全为0只有该位为1的数  然后再取反  容易实现
	//int a = 11;
	//int b = 0;
	////1011   将倒数第三位改成1  然后再改成0
	//b = 1 << 2;//0100
	//a = a | b;
	//printf("%d\n",a);//1111  15
	//a = a & (~b);
	//printf("%d\n",a);//1011  11

	//前置后置++  --
	//int a = 10;
	////printf("%d\n",++a);//11  先自增后赋值  
	//printf("%d\n",a++);//10  先赋值后自增    --同理

	//关系操作符
	// <  >    <=  >=  !=  ==       ==  和  = 经常写错

	//逻辑操作符    && 逻辑与  || 逻辑或
	//  1 & 2 = 0    1 && 2 == 1        1 | 2  = 3   1 || 2 =  1
	// 逻辑与和逻辑或的特点

	//// 360 笔试题
	//int i = 0;
	//int a = 0;
	//int b = 2;
	//int c = 3;
	//int d = 4;
	////i = a++ && ++b && d++;//a++ && 后置++ 先用a的值  0 && 后面的数 都是0  所以后面的表达式不会再计算了  b 和 d的值不变  但是表达式完成之后a = 1
	////printf("a = %d\n b = %d\n c = %d\n d = %d\n",a,b,c,d);
	//i = a++ || ++b || d++;
	//printf("a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);//同上  || d++ 前面的表达式已经为1   后面不会在计算   d的值不变	

	//条件操作符
	//也叫三目运算符  exp1 ? exp2 : exp3  表达式1如果为真  计算表达式2  整个表达式的结果为表达式2      表达式1为假   计算表达式3  整个表达式的结果为表达式3
	// b = (a > 5 ? 3 : -3)等价于
	//int a = 0; 
	//int b = 0;
	//if (a > 5)
	//{
	//	b = 3;
	//}
	//else
	//{
	//	b = -3;
	//}

	//逗号表达式
	//exp1,exp2,exp3,................expN
	//逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。
	//代码1
	//int a = 1;
	//int b = 2;
	//int c = (a > b, a = b + 10, a, b = a + 1);
	//printf("c = %d\n",c);

	//代码2
	//if (a = b + 1, c = a / 2, d > 0)

	//代码3
	//a = get_val();
	//count_val(a);
	//while (a > 0)
	//{
	//	//业务处理
	//	a = get_val();
	//	count_val(a);
	//}
	//用逗号表达式改写上面代码
	//while (a = get_val(), count_val(a), a > 0)
	//{
	//	//业务处理
	//}

	//下标引用、函数调用和结构成员
	//1.[]下标引用操作符    数组名 + 索引值  两个操作数
	//int a[10] = { 0 };
	//a[4] = 10; //数组名 a    索引值 4
	//return 0;
//}

	//2.函数调用操作符  接受一个或者多个操作数：第一个操作数是函数名，剩余操作数是传递给函数的参数
//int get_max(int x, int y)
//{
//	return x > y ? x : y;
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//调用函数的时候()就是函数调用操作符
//	int max = get_max(a, b);//三个操作数  get_max  a  b
//	printf("max = %d\n",max);
//	return 0;
//}

//3.访问一个结构体成员
//(1)  .   结构体.成员名
//(2)  ->  结构体指针->成员名
//学生
//int  float 
//相当于一个类型 自定义的   struct Stu
//struct Stu 
//{
//	char name[20];
//	int age;
//	char id[20];
//};
//
//#include<string.h>
//int main()
//{
//	int a = 10;
//	//使用struct Stu 创建了一个学生对象s1  并初始化
//	struct Stu s1 = {"杨若黎",20,"20193062"};
//	//printf("%s\n",s1.name);
//	//printf("%d\n", s1.age);
//	//printf("%s\n", s1.id);
//	struct Stu* ps = &s1;
//	printf("%s\n",ps->name);
//	printf("%s\n", (*ps).name);
//	return 0;
//}

//表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定。  同样，有些表达式的操作数在求值的过程中可能需要转化为其他类型
// 1. 隐式类型转换
//C的整形算术运算总是至少以缺省整形类型的精度来定义的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整形，这些转换称为整形提升。
//这是因为表达式的整形运算要在CPU的相应运算器件内执行，CPU内整形运算器ALU的操作数的字节长度一般是int的字节长度，同时也是CPU通用寄存器的长度
//所以都要转化为 int  或 unsigned int  才能送去CPU去执行运算
//如何进行整形提升？
//整形提升是按照变量的数据类型的符号位来提升的   有符号补符号位  无符号补0
//实例 1
//int main()
//{
//	char a = 3;
//	//00000000000000000000000000000011   截断从最小字节开始截断
//	//00000011 - a
//	char b = 127;
//	//00000000000000000000000001111111
//	//01111111 - b
//	//a和b如何相加
//	//00000011   最高位0是符号位   提升时补符号位 00000000000000000000000000000011
// 	//01111111                                    00000000000000000000000001111111
//	//结果 00000000000000000000000010000010
//	char c = a + b;
//	// c 要被截断10000010 
//	//   然后提升11111111111111111111111110000010  -  补码   
//	//           11111111111111111111111110000001  -  反码   补码-1
//	//           10000000000000000000000001111110  -  原码
//	// 然后再截断存储1111110
//	printf("%d\n",c);//所以结果是-126
//}

//实例2      ==  也会发生整形提升
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)//1111111111111111111111111011  不等于  0xb6  所以不执行打印a
//	{
//		printf("a\n");
//	}
//	if (b == 0xb600)
//	{
//		printf("b\n");
//	}
//	if (c == 0xb6000000)
//	{
//		printf("c\n");
//	}
//}

////实例3   c只要参与表达式运算就会发生整形提升，表达式+c，所以sizeof（+4）是四个字节  sizeof(-c)也一样
//int main()
//{
//	char c = 1;
//	printf("%u\n",sizeof(c));//1
//	printf("%u\n", sizeof(+c));//4
//	printf("%u\n", sizeof(!c));//1
//	return 0;
//}

//算术转换  int  和  float等所占空间更大的数进行运算时  要合理转换类型

//操作符的属性
//1.操作符的优先级  看文件表格
//2.操作符的结合性
//3.是否控制求值顺序
