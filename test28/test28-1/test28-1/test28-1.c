#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//深度剖析数据在内存中的存储
//一、数据类型详细介绍
//二、整形在内存中的存储：原码、反码、补码
//三、大小端字节序介绍及判断
//四、浮点型在内存中的存储解析

//一、数据类型详细介绍
//类型的意义：
//1.使用这个类型开辟内存空间的大小(大小决定使用范围)
//2.如何看待内存空间的视角
//int main()
//{
//	int a = 10;//4个字节   虽然都是10  内存中存储方式不一样 
//	float f = 10.0;//4个字节
//	short a = 10;
//	short int b = 10;//int 可以省略
//	return 0;
//}

//类型的基本归类：
//1.内置类型(char short int long float double)
//2.自定义类型(构造类型)
//1.内置类型
//整形家族：
//char   
//    unsigned char
//    signed char
//short
//    unsigned short [int]
//    signed short [int]
//int
//    unsigned int
//    signed int
//long
//    unsigned long [int]
//    signed long [int]

//浮点型家族 
//float  单精度浮点型  double  双精度浮点型

//2.构造类型
//数组类型    int arr[10]  的类型 -> int[10]   改变括号中的数字和前面的int  都在改变数组的类型   int[10]  int[5]  char[5]  三者均不等价
//结构体类型  struct
//枚举类型    enum
//联合类型    union

//指针类型  大小都一样  都是四个字节或者八个字节   取决于系统是多少位
//int* pi;  char*pc;  float* pf;  void* pv;

//空类型
//void表示空类型(无类型) 通常应用于函数的返回类型、函数的参数、指针类型。
//void test(void)
//{
//	printf("hehe\n");
//}
//int main()
//{
//	test(100);
//	return 0;
//}

//二、整形在内存中的存储
//计算机中的整形有符号数有三种表示方法：即原码、反码、补码 (均由符号位和数组位构成)       无符号数：原码反码补码相同
//符号位都是 0表示正 1表示负   而数值位三种方式各不相同
//原码：直接将数字按照正负数形式翻译成二进制
//int main()
//{
//	int a = 10;//4个字节 -  32bit        正数原码反码补码三码相同
//	//00000000000000000000000000001010 - 原码
//	//00000000000000000000000000001010 - 反码
//	//00000000000000000000000000001010 - 补码
//	//0x0000000a
//	int b = -20;
//	//10000000000000000000000000010100 - 原码
//	//11111111111111111111111111101011 - 反码   符号位不变  其他位取反
//	//11111111111111111111111111101100 - 补码   反码 + 1
//	//0xffffffec
//	return 0;
//}
//对于整形来说：数据存放内存中其实存放的是补码
//因为使用补码，可以将符号位和数值域统一处理，同时，加法和减法也可以统一处理(CPU只有加法器)此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路

//大小端介绍
//什么大端小端
//大端(存储)模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中
//小端(存储)模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中
//为什么有大端和小端: