#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//整形和浮点型的数据在内存中的存储和取出的方式不一样  浮点数存储的例子   浮点型后面默认6个小数位  
int main()
{
	int n = 9;//0 00000000 00000000000000000001001 
	float* pFloat = (float*)&n;// (-1)^0*0.00000000000000000001001*2^(-126)  所以结果打印出来是0.000000
	printf("n的值为: %d\n", n);
	printf("*pFloat的值为: %f\n", *pFloat);
	*pFloat = 9.0; // 1001.0   (-1)^0*1.001*2^3     0 10000010 00100000000000000000000   
	printf("num的值为: %d\n", n);// 2^20 + 2^24 + 2^30  1091567616
	printf("*pFloat的值为: %f\n", *pFloat);//9.000000
	return 0;
}
//浮点数在内存中的存储：先表示成二进制数  然后 (-1)^S*M*2^E   S表示符号位    M表示有效数字 >= 1 && < 2   E取值取最高二进制位-1   
//例如 5.0 = 101.0   =  (-1)^0*1.01*2^2
//     0.5 = 0.1     =  (-1)^0*1.0 *2^(-1)
//所以只需要存储S M E就能还原浮点数
//对于32位的浮点数，最高的一位是符号位S，接着的8位是指数E，剩下的23位为有效数字M  
//对于64位的双精度的浮点数，最高一位是符号位S，接着的11位是指数E,剩下的52位为有效数字M
//对于M E 不是简单的丢进去，还有一些特殊的规定，见图M和E的规定。

//E是一个无符号数 但是也存在要取负值的情况 所以要加上一个中间数   8位+127   11位+1023
//int main()
//{
//	float f = 5.5;
//	//5.5
//	//101.1
//	//(-1)^0*1.011*2^2
//	//S = 0
//	//M = 1.011
//	//E = 2	
//	//实际上E = 2 + 127 = 129  // 10000001
//	//实际上M 01100000000000000000000
//	//总体32位  0100 0000 1011 0000 0000 0000 0000 0000
//	//对应16进制  0x40b00000    调试看内存就行
//	return 0;
//}