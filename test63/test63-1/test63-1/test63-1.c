#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//动态内存管理
//本章重点
//为什么存在动态内存分配
//动态内存函数的介绍
//malloc
//free
//calloc
//realloc
//常见的动态内存错误
//几个经典的笔试题
//柔性数组


//C语言是可以创建变长数组 - C99中增加了

//为什么存在动态内存分配
//我们已经掌握的内存开辟方式有:
//int va1 = 20;//在栈空间上开辟四个字节
//char arr[10] = { 0 };//在栈空间上开辟10个字节的连续空间
//但是上述的开辟空间的方式有两个特点:
//1.空间开辟大小是固定的。
//2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配
//但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了。


//malloc和free
//C语言提供了一个动态内存开辟的函数 :
//void* ma11oc(sizet size);
//这个函数向内存申请一块连续可用的空间, 并返回指向这块空间的指针。
//如果开辟成功，则返回一个指向开辟好空间的指针。
//如果开辟失败, 则返回一个NULL指针，因此malloc的返回值一定要做检查
//返回值的类型是void*，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
//如果参数size为0, malloc的行为是标准是未定义的，取决于编译器。

#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main()
{
	//向内存申请10个整形的空间
	int* p = (int*)malloc(40);
	if (p == NULL)
	{
		printf("%s\n",strerror(errno));
	}
	else
	{
		//正常使用空间
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			*(p + i) = i;
		}
		for (i = 0; i < 10; i++)
		{
			printf("%d ",*(p + i));
		}
	}
	//当动态申请的空间不再使用的时候
	//就应该还给操作系统
	free(p);
	p = NULL;
	return 0;
}

//C语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的.
//void* free(void* ptr);
//free函数用来释放动态开辟的内存。
//如果参数 ptr指向的空间不是动态开辟的，那free函数的行为是未定义的。
//如果参数 ptr是NULL指针，则函数什么事都不做。 malloc和free都声明在stdlib.h 头文件中

